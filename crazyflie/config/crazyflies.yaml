# named list of all robots
robots:
  cf2:
    enabled: true
#    uri: radio://0/80/1M/E7E7E7E7B4 # first
    uri: radio://0/80/2M/E7E7E7E7B5 # second
#    uri: udp://0.0.0.0:19850 # simul
    
    initial_position: [0.0, 0.0, 0.0]
    type: cf21  # see robot_types

# Definition of the various robot types
robot_types:
  cf21:
    big_quad: false
    motion_capture:
      enabled: true #원래는 true
      # only if enabled; see motion_capture.yaml
      marker: default_single_marker
      dynamics: default
    battery:
      voltage_warning: 3.8  # V
      voltage_critical: 3.7 # V
    firmware_logging:
      enabled: true
      default_topics:
        pose:
          frequency: 10
        status:
          frequency: 1
      custom_topics:

#        cf_F_input_raw:   # 매트랩로깅
#          frequency: 20
#          vars: [suWrenchObs.suWFx, suWrenchObs.suWFy, suWrenchObs.suWFz]
#        cf_F_input_scaled:   # 매트랩로깅
#          frequency: 20
#          vars: [suWrenchObs.suWFx_scaled, suWrenchObs.suWFy_scaled, suWrenchObs.suWFz_scaled]
#        cf_voltage: # 매트랩로깅. voltage 데이터임. hz를 높이니까 노이즈 껴서 필터를 검. 첫번째꺼는 그냥, 두번째꺼는 필터건 데이터
#          frequency: 1
#          vars: [pm.vbat, suWrenchObs.suV]
        cf_setpoint_pos: # 매트랩로깅. 제어기에서 푸는 최종 위치 커맨드
          frequency: 10
          vars: [ctrltarget.x, ctrltarget.y, ctrltarget.z, ctrltarget.yaw_sp]
#        cf_Fext_MOB:        # MOB
#          frequency: 20
#          vars: [suWrenchObs.suFextX, suWrenchObs.suFextY, suWrenchObs.suFextZ]
#        cf_Fext_DOB:        # DOB
#          frequency: 20
#          vars: [suWrenchDOB.suFextX, suWrenchDOB.suFextY, suWrenchDOB.suFextZ]
        # su_cmd_dbg:
        #   frequency: 1
        #   vars: [su_cmd_dbg.use_vel_mode, su_cmd_dbg.cmd_fx]
        # vel_from_pos:   # 매트랩로깅
        #   frequency: 10
        #   vars: [suVelFromPos.vx, suVelFromPos.vy, suVelFromPos.vz]

# For PID Gain Tuning
        stateEstimate_velocity:   # global
          frequency: 10
          vars: [stateEstimate.vx, stateEstimate.vy, stateEstimate.vz]
        stateEstimate_acc:   # global
          frequency: 10
          vars: [stateEstimate.ax, stateEstimate.ay, stateEstimate.az]
        state_body_vel:    # yaw-aligned body
          frequency: 10
          vars: [posCtl.bodyVX, posCtl.bodyVY]   # 또는 내부 state_body_vx/y 로그
#        gyro_feedback:
#          frequency: 10
#          vars: [gyro.x, gyro.y, gyro.z]
        vel_des:            # yaw-aligned body
          frequency: 11
          vars: [posCtl.targetVX, posCtl.targetVY, posCtl.targetVZ]
        att_des:
          frequency: 10
          vars: [controller.roll, controller.pitch, controller.yaw]
#        rate_des:
#          frequency: 10
#          vars: [controller.rollRate, controller.pitchRate, controller.yawRate]
        # ---------------------------
        # Kalman attitude / attitude-error debug (SEUK)
        # ---------------------------
        kalman_att_qComp:
          frequency: 10
          vars: [kalman.q0, kalman.q1, kalman.q2, kalman.q3]

        kalman_att_err:
          frequency: 10
          vars: [kalman.stateD0, kalman.stateD1, kalman.stateD2]
          
    firmware_params:
      commander:
        enHighLevel: 1
      stabilizer:   # 제어기랑 상태관측기 고를 수 있음
        estimator: 2 # 1: complementary, 2: kalman
        controller: 1 # 1: PID, 2: mellinger, 3: INDI, 4: Brescianini, 5: Lee
      locSrv:
        extPosStdDev: 1e-3
        extQuatStdDev: 0.5e-1
      # ================================================
      #     Custom modules
      # ================================================
      su_cmd:
        use_vel_mode: 0.0    # 0: 그냥 위치로 씀, 1: 들어오는 걸 vel로 보고 적분
        adm_M: 0.0           # 어드미턴스 M
        adm_D: 0.0           # 어드미턴스 D
        adm_K: 0.0           # 어드미턴스 K
        cmd_fx: 0.0          # 힘커맨드인데 일단 무시
      su_platform:
        mass: 0.0393          # 또는 su_mass 기본값
        Jxx: 1.9e-5
        Jyy: 1.9e-5
        Jzz: 3.0e-5
      su_wrench:
        Kf: 2.0               # 선운동량 관측 이득
        Ktau: 2.0             # 각운동량 관측 이득
        deadzone_F: 0.0
        deadzone_T: 0.0
        voltage_model_a: 0.0
        voltage_model_b: 1.0
        vbat_alpha: 0.005
        dt_alpha: 0.01
        mob_alpha: 1.0
        dob_wn: 7.0
        dob_zeta: 0.707

      kalman:
        resetEstimation: 0
        # --------------------------------
        # (A) Complementary -> Kalman fusion (roll/pitch error D0/D1 update)
        # --------------------------------
        # 0: off, 1: fuse qComp-based roll/pitch error into D0/D1 in finalize()
        # 그니까 1이면, 칼만 내부상태도 complementary를 봄
        # fuseCompAttToKalman: 0
        # 위에 값 1일때만 의미있음. 이걸 줄이면 complementary가 우세, 아니면 kalamn이 우세.
        # compFuseStdRP 작게 → R(측정분산) 작음 → K gain 커짐 → Kalman roll/pitch가 qComp를 더 세게 따라감
        # compFuseStdRP 크게 → comp를 “노이즈 큰 센서”로 취급 → Kalman은 덜 따라감
        # compFuseStdRP: 0.05


        # --------------------------------
        # SEUK: complementary attitude output / slave
        # --------------------------------
        # 0: Kalman attitude 사용 (기존과 동일)
        # 1: complementary attitude로 stateEstimate.* (roll/pitch/yaw, q, vel, acc) 출력
        # 2: complementary attitude로 stateEstimate.* 근데이제 yaw는 kalman
        useCompAttOut: 2

        # 0: Kalman 내부 q/R는 원래대로 두고, 출력만 complementary 사용
        # 1: Kalman 내부 q/R도 complementary에 동기화 (내부 dynamics도 comp 기반)
        slaveAttToComp: 0

        # complementary Mahony filter roll/pitch correction gain
        compKp: 0.7
        compKi: 0.03



        # --------------------------------
        # Slave mode covariance recovery tuning
        # --------------------------------
        # std dev [rad] used when slaveAttToComp=1 and you reset P(D0/D1)
#        compSlaveStdRP: 0.10


      posCtlPid:
#        xKp: 5.0
#        yKp: 5.0
#        zKp: 5.0

#        xKd: 1.0
#        yKd: 1.0
#        zKd: 1.0
        xKi: 0.0
        yKi: 0.0
        zKi: 0.0
      velCtlPid:
#        vxKp: 18.0
#        vyKp: 18.0
#        vzKp: 18.0
        vxKi: 0.
        vyKi: 0.
        vzKi: 0.
#        vxKd: 1.5
#        vyKd: 1.5
#        vzKd: 1.5


      pid_attitude:
        roll_kp: 9.0
        pitch_kp: 15.0
        yaw_kp: 8.0
        roll_ki: 0.0
        pitch_ki: 0.0
        # yaw_ki: 0.0
        roll_kd: 1.3
        pitch_kd: 2.0
        yaw_kd: 1.2
      pid_rate:
#        roll_kp: 200.0
#        pitch_kp: 200.0
#        yaw_kp: 120.0
        roll_ki: 0.0
        pitch_ki: 0.0
        yaw_ki: 0.0
#        roll_kd: 4.0
#        pitch_kd: 4.0
#        yaw_kd: 4.0
    broadcasts:
      num_repeats: 1 # number of times broadcast commands are repeated
      delay_between_repeats_ms: 1 # delay in milliseconds between individual repeats
